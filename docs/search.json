[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "New Year, New Blog?",
    "section": "",
    "text": "I’ve contemplated creating a blog for a while now with the hopes of achieving a few personal goals of mine. Firstly, I hope this can become a library of useful information I have accumulated in my journey thus far. Previously, interesting tricks, tips and code have often become buried in a maze of folders, forgotten and lost over time which is a shame.\nSecondly, I hope this blog can act as a motivator for myself to search out new developments in statistics and R programming - with the added bonus of potentially helping out one or two other people a long the way. It has long been a goal of mine to release useful information freely available to the public. I find it a shame when a persons learning and development is limited through pesky pay-walls.\nAnother aspiration of mine is to become better at writing and communicate complex ideas in a simple manner such that statisticians and non-statisticians alike can understand. Finally, I like the idea of owning something myself, a place to have free reign over what is posted and how."
  },
  {
    "objectID": "posts/Pipes/index.html#why",
    "href": "posts/Pipes/index.html#why",
    "title": "More than just a pipe dream",
    "section": "Why?",
    "text": "Why?\nIn addition to the ability to easily chain events together it is relatively readable and interpretable in comparison to data.table or at least to me. That isn’t to say I don’t like data.table, it has its place and advantages with larger data sets but I do not often work with such data sets that the efficiency gain outweighs the trade-off between readability. It is important to balance such things and to consider QC’ers or the possibility of someone taking over a piece of code from you."
  },
  {
    "objectID": "posts/Pipes/index.html#native-vs-magrittr",
    "href": "posts/Pipes/index.html#native-vs-magrittr",
    "title": "More than just a pipe dream",
    "section": "Native vs Magrittr",
    "text": "Native vs Magrittr\nThere are some subtle differences between the native and magrittr pipe, including operational efficiency/speed, bracket usage, placeholder syntax, etc. For example, using rlang we can see what is happening under the hood between the two pipes. I.e.,\nThe R native pipe:\n\nrlang::expr(x |&gt; f())\n\nf(x)\n\n\nMagrittr forward pipe:\n\nrlang::expr(x %&gt;% f())\n\nx %&gt;% f()\n\n\nWe can see that the native pipe is changing the structure (evaluating the expression as syntax) whereas the magrittr pipe is evaluated as a function call and thus is slightly slower.\n\nmicrobenchmark::microbenchmark(\"Direct\" = sqrt(4),\n                               \"Native\" = 4 |&gt; sqrt(),\n                               \"Magrittr\" = 4 %&gt;% sqrt())\n\nUnit: nanoseconds\n     expr  min   lq mean median   uq   max neval\n   Direct  100  100  168    200  200   800   100\n   Native  100  100  509    200  200 34600   100\n Magrittr 2900 3000 4199   3500 3700 42100   100\n\n\nand comparing with data.table and aggregate:\n\nset.seed(42)\ndf &lt;-\n  data.frame(Groups = rep(\n    c(\n      \"Pembrolizumab\",\n      \"Nivolumab\",\n      \"Atezolizumab\",\n      \"ipilimumab\",\n      \"Placebo\"\n    ),\n    100000\n  ),\n  times = rnorm(n = 10000, mean = 5, sd = 1))\n\n\n\ntest &lt;- microbenchmark::microbenchmark(\n  \"|&gt;\" =\n    (df |&gt;\n       group_by(Groups) |&gt;\n       summarise(across(everything(), sum))),\n  \"%&gt;%\" =\n    (df %&gt;%\n       group_by(Groups) %&gt;%\n       summarise(across(everything(), sum))),\n  \"aggregate\" =\n    (aggregate(. ~ Groups, df, sum)),\n  \"data.table\" =\n    (setDT(df)[,lapply(.SD, sum), by = \"Groups\"]),\n  times = 100\n)\n\ntest\n\nUnit: milliseconds\n       expr      min        lq      mean    median        uq      max neval\n         |&gt;  23.3272  38.05155  52.36764  44.24500  52.26330 233.9848   100\n        %&gt;%  21.5771  37.71775  51.90386  43.46830  56.31645 263.8713   100\n  aggregate 241.8274 405.50815 478.27134 480.08175 531.10290 770.5458   100\n data.table  17.7645  25.81990  39.45325  33.83845  42.78820 146.0053   100\n\n\nThere is a wonderful answer here which goes through in more detail some of the differences."
  },
  {
    "objectID": "posts/Pipes/index.html#magrittr",
    "href": "posts/Pipes/index.html#magrittr",
    "title": "More than just a pipe dream",
    "section": "Magrittr",
    "text": "Magrittr\n\nForward pipe (%&gt;%)\nAs briefly mentioned, the forward pipe from magrittr behaves similarly to the native pipe in R and allows you to apply potentially many functions in a sequence of code. It will take in values from the LHS and apply functions on the RHS. For example, here we are doing the following:\n\nSelect columns species, sepal length and petal length from iris\nFor the newly subsetted data, replace dots with underscores and make names lower case\ndisplay the first 6 rows of the data frame\n\n\niris %&gt;% \n  select(Species,Sepal.Length,Petal.Length) %&gt;%\n  rename_with(~tolower(gsub(\"\\\\.\",\"_\",.)), everything()) %&gt;% \n  head()\n\n  species sepal_length petal_length\n1  setosa          5.1          1.4\n2  setosa          4.9          1.4\n3  setosa          4.7          1.3\n4  setosa          4.6          1.5\n5  setosa          5.0          1.4\n6  setosa          5.4          1.7\n\n\n\n\nAssignment pipe (%&lt;&gt;%)\nTypically after applying a series of functions we want to save the result. If you are writing back to the original object a quicker step than doing:\n\n# Create data frame of normally distributed values\ndf &lt;- data.frame(col=rnorm(100,10,1))\n# Remove values greater than 10\ndf &lt;- df %&gt;% filter(col&lt;10)\n\nis to simply use the assignment:\n\n# Create data frame of normally distributed values\ndf &lt;- data.frame(col=rnorm(100,10,1))\n# Remove values greater than 10\ndf %&lt;&gt;% filter(col&lt;10)\n\n\n\nEager pipe (%!&gt;%)\nThe eager pipe evaluates the piped input at each step, you’ll notice when the code below is run with the “lazy” forward pipe, messages appears in a backwards order.\n\n# Set seed for reproducibility\nset.seed(42)\n# Create main function with forward pipes\nmain_fun &lt;- function() {\n  cli::cli_progress_step(msg = \"Running main function\")\n  sample(1:100,50,replace=T) %&gt;% \n    fun1() %&gt;% \n    fun2() %&gt;% \n    fun3()\n}\n# Create sub functions\nfun1 &lt;- function(x){cli::cli_progress_step(msg = \"Function 1\");Sys.sleep(2); x*2}\nfun2 &lt;- function(x){cli::cli_progress_step(msg = \"Function 2\");Sys.sleep(2); x+5}\nfun3 &lt;- function(x){cli::cli_progress_step(msg = \"Function 3\");Sys.sleep(2); mean(x)}\n\n# call main function\nmain_fun()\n\nℹ Running main function\n\n\nℹ Function 3\n\n\nℹ Function 2\n\n\nℹ Function 1\n\n\n✔ Function 1 [2.4s]\n\n\n\n\n\nℹ Function 2\n✔ Function 2 [5.3s]\n\nℹ Function 3\n✔ Function 3 [7.9s]\n\nℹ Running main function\n✔ Running main function [8.6s]\n\n\n[1] 107.8\n\n\nHowever, when applying the ‘eager’ pipe we see a more intuitive output which is useful for debugging as messages will appear in the order the functions are applied.\n\n# Set seed for reproducibility\nset.seed(42)\n# Create main function with eager pipes\nmain_fun &lt;- function() {\n  cli::cli_progress_step(msg = \"Running main function\")\n  sample(1:100,50,replace=T) %!&gt;% \n    fun1() %!&gt;% \n    fun2() %!&gt;% \n    fun3()\n}\n# Create sub functions\nfun1 &lt;- function(x){cli::cli_progress_step(msg = \"Function 1\");Sys.sleep(2); x*2}\nfun2 &lt;- function(x){cli::cli_progress_step(msg = \"Function 2\");Sys.sleep(2); x+5}\nfun3 &lt;- function(x){cli::cli_progress_step(msg = \"Function 3\");Sys.sleep(2); mean(x)}\n\n# call main function\nmain_fun()\n\nℹ Running main function\n\n\nℹ Function 1\n\n\n✔ Function 1 [2.3s]\n\n\n\n\n\nℹ Running main function\nℹ Function 2\n✔ Function 2 [2.5s]\n\nℹ Running main function\nℹ Function 3\n✔ Function 3 [2.3s]\n\nℹ Running main function\n✔ Running main function [8.4s]\n\n\n[1] 107.8\n\n\n\n\nTee pipe (%T&gt;%)\nA regular forward pipe will update the value of the expression on the LHS from expressions on the RHS and is performed sequentially. A useful, less well-known pipe is the ‘Tee Pipe’. Similar to the Tee Pipe used by your local plumber to create a junction through a T shape, the Tee Pipe takes the input on the LHS and creates a junction to bypass functions which would normally terminate. A popular example is the use of plot with colSums\n\niris %&gt;%\n select(Sepal.Length,Sepal.Width) %&gt;%\n plot %&gt;%\n colSums\n\nError in colSums(.): 'x' must be an array of at least two dimensions\n\n\n\n\n\nThe above code will produce an error as the plot command does not return anything and therefore colSums will throw an error. Instead we can use a Tee Pipe to pass the data with Sepal.Length and Sepal.Width to both the plot and colSums argument.\n\n\n\n\nflowchart LR\n  A[iris] --&gt; B[select]\n  B --&gt; C{T}\n  C --&gt; D[plot]\n  C --&gt; E[colSums]\n\n\n\n\n\n\niris %&gt;%\n select(Sepal.Length,Sepal.Width) %T&gt;%\n plot %&gt;%\n colSums\n\n\n\n\nSepal.Length  Sepal.Width \n       876.5        458.6 \n\n\nThis is a fairly trivial example but it does have its uses. By inserting a print command it can be used to help with debugging or we can save an object in the middle of pipes.\nIt should also be noted that the use of curly brackets will give the same result.\n\niris %&gt;%\n  select(Sepal.Length,Sepal.Width) %&gt;%\n  {plot(.)\n  colSums(.)}\n\n\n\n\nSepal.Length  Sepal.Width \n       876.5        458.6 \n\n\nWhat about the example below?\n\niris %&gt;%\n  select(Sepal.Length,Sepal.Width) %T&gt;%\n  sqrt %&gt;%\n  colSums\n\nSepal.Length  Sepal.Width \n       876.5        458.6 \n\n\nYou might be wondering why this appears to not work, shouldn’t this output the square root and the column sums? A forward pipe %&gt;% will return the result having applied the function of the RHS, whereas the %T&gt;% will return the original value of the LHS itself."
  },
  {
    "objectID": "posts/Pipes/index.html#zeallot-pipe--",
    "href": "posts/Pipes/index.html#zeallot-pipe--",
    "title": "More than just a pipe dream",
    "section": "Zeallot pipe (%<-%)",
    "text": "Zeallot pipe (%&lt;-%)\nThe zeallot package contains pipes which allow for multiple assignment. The operator allows for the user to assign from LHS to RHS or RHS to LHS. A simple example below shows how I can assign values to x and y.\n\nc(3,4) %-&gt;% c(x,y)\n\nc(x,y) %&lt;-% c(3,4)\n\n\ncat(\"x = \", x, \"\\ny = \", y)\n\nx =  3 \ny =  4\n\n\n\ndf1 &lt;- \n  data.frame(\n    subject_id = c(\"S001-0001\", \"S001-0002\", \"S001-0003\"),\n    Trt = c(\"Pembrolizumab\", \"Pembrolizumab\", \"nivolumab\"),\n    status = c(1,1,1),\n    age = c(38,64,24),\n    time = c(10,38,83)\n    )\n\ndf2 &lt;-\n  data.frame(\n    subject_id = c(\"S002-0001\", \"S002-0002\", \"S002-0003\"),\n    Trt = c(\"atezolizumab \", \"Pembrolizumab\", \"atezolizumab\"),\n    status = c(1,1,1),\n    age = c(24,67,12),\n    time = c(34,92,145)\n    )\n\n# Create data.tables\npurrr::map(mget(ls(pattern = '^df\\\\d+$')), as.data.table) %-&gt;%\n          c(df1, df2)\n\n# See result\nlist(df1,df2) %&gt;% \n  lapply(\\(x) class(x))\n\n[[1]]\n[1] \"data.table\" \"data.frame\"\n\n[[2]]\n[1] \"data.table\" \"data.frame\""
  },
  {
    "objectID": "misc.html",
    "href": "misc.html",
    "title": "misc",
    "section": "",
    "text": "I will be updating this page periodically to display a network diagram of the books I have read each calendar year. You might be asking why would I do that. The only answer I can think of is because it seems like a neat way to display data and to motivate me to read more (Note, the network below is not complete but it is interactive!) :)\n\n2024\n\nmiserables = FileAttachment(\"books_24.json\").json()\n\nfunction ForceGraph(\n  {\n    nodes, // an iterable of node objects (typically [{id}, …])\n    links // an iterable of link objects (typically [{source, target}, …])\n  },\n  {\n    nodeId = (d) =&gt; d.id, // given d in nodes, returns a unique identifier (string)\n    nodeGroup, // given d in nodes, returns an (ordinal) value for color\n    nodeGroups, // an array of ordinal values representing the node groups\n    nodeTitle, // given d in nodes, a title string\n    nodeFill = \"currentColor\", // node stroke fill (if not using a group color encoding)\n    nodeStroke = \"#fff\", // node stroke color\n    nodeStrokeWidth = 2, // node stroke width, in pixels\n    nodeStrokeOpacity = 1, // node stroke opacity\n    nodeRadius = 7, // node radius, in pixels\n    nodeStrength=-100,\n    linkSource = ({ source }) =&gt; source, // given d in links, returns a node identifier string\n    linkTarget = ({ target }) =&gt; target, // given d in links, returns a node identifier string\n    linkStroke = \"#999\", // link stroke color\n    linkStrokeOpacity = 0.6, // link stroke opacity\n    linkStrokeWidth = 3, // given d in links, returns a stroke width in pixels\n    linkStrokeLinecap = \"round\", // link stroke linecap\n    linkStrength=.1,\n    colors = d3.schemeTableau10, // an array of color strings, for the node groups\n    width = 640, // outer width, in pixels\n    height = 600, // outer height, in pixels\n    invalidation // when this promise resolves, stop the simulation\n  } = {}\n) {\n  // Compute values.\n  const N = d3.map(nodes, nodeId).map(intern);\n  const LS = d3.map(links, linkSource).map(intern);\n  const LT = d3.map(links, linkTarget).map(intern);\n  if (nodeTitle === undefined) nodeTitle = (_, i) =&gt; N[i];\n  const T = nodeTitle == null ? null : d3.map(nodes, nodeTitle);\n  const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);\n  const W =\n    typeof linkStrokeWidth !== \"function\"\n      ? null\n      : d3.map(links, linkStrokeWidth);\n  const L = typeof linkStroke !== \"function\" ? null : d3.map(links, linkStroke);\n\n  // Replace the input nodes and links with mutable objects for the simulation.\n  nodes = d3.map(nodes, (_, i) =&gt; ({ id: N[i] }));\n  links = d3.map(links, (_, i) =&gt; ({ source: LS[i], target: LT[i] }));\n\n  // Compute default domains.\n  if (G && nodeGroups === undefined) nodeGroups = d3.sort(G);\n\n  // Construct the scales.\n  const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);\n\n  // Construct the forces.\n  const forceNode = d3.forceManyBody();\n  const forceLink = d3.forceLink(links).id(({ index: i }) =&gt; N[i]);\n  if (nodeStrength !== undefined) forceNode.strength(nodeStrength);\n  if (linkStrength !== undefined) forceLink.strength(linkStrength);\n\n  const simulation = d3\n    .forceSimulation(nodes)\n    .force(\"link\", forceLink)\n    .force(\"charge\", forceNode)\n    .force(\"center\", d3.forceCenter())\n    .force('collide', d3.forceCollide(function(d) {\n    return d.id === \"j\" ? 20 : 10\n  }))\n    .on(\"tick\", ticked);\n\n  const svg = d3\n    .create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [-width / 2, -height / 2, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  const link = svg\n    .append(\"g\")\n    .attr(\"stroke\", typeof linkStroke !== \"function\" ? linkStroke : 1.5)\n    .attr(\"stroke-opacity\", linkStrokeOpacity)\n    .attr(\n      \"stroke-width\",\n      typeof linkStrokeWidth !== \"function\" ? linkStrokeWidth : 1.5\n    )\n    .attr(\"stroke-linecap\", linkStrokeLinecap)\n    .selectAll(\"line\")\n    .data(links)\n    .join(\"line\");\n\n  const node = svg\n    .append(\"g\")\n    .attr(\"fill\", nodeFill)\n    .attr(\"stroke\", nodeStroke)\n    .attr(\"stroke-opacity\", nodeStrokeOpacity)\n    .attr(\"stroke-width\", nodeStrokeWidth)\n    // SM: change\n    // .selectAll(\"circle\")\n    .selectAll(\"g\")\n    .data(nodes)\n    // SM: change\n    // .join(\"circle\")\n    .join(\"g\")\n    // SM: change\n    // .attr(\"r\", nodeRadius)\n    .call(drag(simulation));\n\n  // SM: change\n  // append circle and text to node &lt;g&gt; (selection of all &lt;g&gt; elements corresponding to each node)\n  node.append(\"circle\").attr(\"r\", nodeRadius);\n  node\n    .append(\"text\")\n    .text(({ index: i }) =&gt; T[i])\n    .attr(\"fill\", \"gray\")\n    .attr(\"stroke\", \"none\")\n    .attr(\"font-size\", \"1em\");\n\n  if (W) link.attr(\"stroke-width\", ({ index: i }) =&gt; W[i]);\n  if (L) link.attr(\"stroke\", ({ index: i }) =&gt; L[i]);\n  if (G) node.attr(\"fill\", ({ index: i }) =&gt; color(G[i]));\n  if (T) node.append(\"title\").text(({ index: i }) =&gt; T[i]);\n  if (invalidation != null) invalidation.then(() =&gt; simulation.stop());\n\n  function intern(value) {\n    return value !== null && typeof value === \"object\"\n      ? value.valueOf()\n      : value;\n  }\n\n  function ticked() {\n    link\n      .attr(\"x1\", (d) =&gt; d.source.x)\n      .attr(\"y1\", (d) =&gt; d.source.y)\n      .attr(\"x2\", (d) =&gt; d.target.x)\n      .attr(\"y2\", (d) =&gt; d.target.y);\n\n    node.attr(\"transform\", (d) =&gt; `translate(${d.x} ${d.y})`);\n    // SM: change\n    // instead of moving the circle centers we transform the whole &lt;g&gt;\n    // .attr(\"cx\", d =&gt; d.x)\n    // .attr(\"cy\", d =&gt; d.y);\n  }\n\n  function drag(simulation) {\n    function dragstarted(event) {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    }\n\n    function dragged(event) {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    }\n\n    function dragended(event) {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    }\n    return d3\n      .drag()\n      .on(\"start\", dragstarted)\n      .on(\"drag\", dragged)\n      .on(\"end\", dragended);\n  }\n\n  return Object.assign(svg.node(), { scales: { color } });\n}\n\nchart = ForceGraph(miserables, {\n  nodeId: d =&gt; d.id,\n  nodeGroup: d =&gt; d.group,\n  nodeTitle: d =&gt; `${d.id}\\n`,\n  linkStrokeWidth: l =&gt; Math.sqrt(l.value),\n  width,\n  height: 600,\n  invalidation // a promise to stop the simulation when the cell is re-run\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere is a data frame containing the books I have read so far in 2024:"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "My name is Corey, I am currently working as a Statistician in the UK. I graduated from UCL with a Masters in Medical Statistics. I enjoy searching for new topics outside of my day-job relating to statistics and programming in R although, I will occasionally use Python to create animated videos using a package called manim (if you’ve seen any 3Blue1Brown video’s on YouTube you will have seen this package implemented there.)\nThis blog will be focused on all things statistics with a focus on medicine although not exclusively. The aim is to push my statistical knowledge, searching for new methods and to catalogue these. A lot of my day job is spent looking at static outputs so where possible I will try to showcase interactive and alternative ways to display data (3-d plots, dynamic figures, tables, etc). The opinions and thoughts expressed here are my own and do not represent anyone else (i.e., employer).\nThis blog is currently written using quarto, an open-source publishing system. At the time of writing, I am using it within RStudio (R 4.3.0)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A Mathemedician’s Blog",
    "section": "",
    "text": "ipcwswitch\n\n\nAn R package for inverse probability of censoring weighting with an application to switches in clinical trials\n\n\n\n\nnews\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nFeb 18, 2024\n\n\nCorey Voller\n\n\n\n\n\n\n  \n\n\n\n\nMore than just a pipe dream\n\n\nThe use of different pipes in R\n\n\n\n\nnews\n\n\nR\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nFeb 11, 2024\n\n\nCorey Voller\n\n\n\n\n\n\n  \n\n\n\n\nMore Efficient Working\n\n\nA guide to standardising scripts\n\n\n\n\nnews\n\n\nR\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nJan 28, 2024\n\n\nCorey Voller\n\n\n\n\n\n\n  \n\n\n\n\nNew Year, New Blog?\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nJan 21, 2024\n\n\nCorey Voller\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Standardising Scripts/index.html",
    "href": "posts/Standardising Scripts/index.html",
    "title": "More Efficient Working",
    "section": "",
    "text": "A useful way to cut-down the amount of repetitive typing is through the use of snippets. My love of snippets is primarily fueled by my inherent laziness (If any future employers are reading this I’m joking). A snippet allows you to automatically insert pieces of code. When I mention custom snippets to people they have often never heard of them but you likely use them without knowing and can be very useful. For example, when I type ‘for’ and press tab, I am met with the following chunk of code.\n\nfor (variable in vector) {\n  \n}\n\nThere are numerous pre-defined snippets that exist in the settings already but we can insert our own customised snippets. You can see some larger snippets on my GitHub here."
  },
  {
    "objectID": "posts/Standardising Scripts/index.html#change-to-when-pasting-file-paths",
    "href": "posts/Standardising Scripts/index.html#change-to-when-pasting-file-paths",
    "title": "More Efficient Working",
    "section": "Change \\ to / when pasting file paths",
    "text": "Change \\ to / when pasting file paths\nThe first snippet is fairly trivial but surprisingly useful in day-to-day working.\n\nsnippet pastefile\n    \"`r gsub('\"', \"\", gsub(\"\\\\\\\\\", \"/\", readClipboard()))`\"\n\nWhen copying and pasting file paths in R you are often met with backslashes which R complains about. The above snippet, when you copy a file path and type ‘pastefile’ it will past the file path location with forward slashes instead."
  },
  {
    "objectID": "posts/Standardising Scripts/index.html#generic-script-template-1",
    "href": "posts/Standardising Scripts/index.html#generic-script-template-1",
    "title": "More Efficient Working",
    "section": "Generic Script Template 1",
    "text": "Generic Script Template 1\nThis is a generic script template with a few features. Firstly, at the top I like to define a few things:\n\nPath of the project\nOverall purpose of the script\nWho wrote the script\nDate (which is taken automatically using sys.time())\nWho and when the code has been QC’d\n\nYou’ll also notice I use ## text ----. The reason for this is it creates section headers which make navigating code easier.\n\n\n\n\n\n\nsnippet header\n    ## ─────────────────────────────────────────────────────────────────────────────\n    ##\n    ## Project: `r paste(gsub(\".*STUDY FOLDER/\",\"\",getwd()))`\n    ##\n    ## Purpose of script:\n    ##\n    ## Author: \n    ##\n    ## Date Created: `r paste(format(Sys.time(), \"%d-%m-%Y\"))`\n    ##\n    ## QC'd by:\n    ## QC date:\n    ##\n    ## ─────────────────────────────────────────────────────────────────────────────\n    ##\n    ## Notes:\n    ##   \n    ##\n    ## ─────────────────────────────────────────────────────────────────────────────\n    ##\n    ## \n    ## set working directory -------------------------------------------------------\n    message(\"Set working directory\")\n\n    # setwd(\"~/\")  \n    \n    ## Options ---------------------------------------------------------------------\n    \n    # options(scipen = 6, digits = 4) # View outputs in non-scientific notation\n\n    ## Load packages ---------------------------------------------------------------\n    message(\"Load packages\")\n\n    ## Set file paths --------------------------------------------------------------\n    message(\"Set file paths\")\n\n    base.path &lt;- \"\"\n    data.path &lt;- \"\"\n    output.path &lt;- \"\"\n    template.path &lt;- \"\"\n\n\n    ## Load data -------------------------------------------------------------------\n    message(\"Load data\")\n     \n    # data &lt;- fread(file.path(data.path, \".csv\")) # or read.csv, etc\n    # load(x,file.path(data.path,\".RData\"))\n    # load(file.path(\"C:/Users/isfar.RData\"), isfar_env &lt;- new.env())\n\n\n    ## First Section ---------------------------------------------------------------\n    message(\"First Section\")\n\n    ## Second Section --------------------------------------------------------------\n    message(\"Second Section\")\n\n\n    ## Third Section ---------------------------------------------------------------\n    message(\"Third section\")\n\n\n    ## Output  ---------------------------------------------------------------------\n    message(\"Output\")\n\n    # save(x,file.path(output.path,\".RData\"))\n    # write.csv(x,file.path(output.path,\"x.csv\")"
  },
  {
    "objectID": "posts/Standardising Scripts/index.html#config-script-template",
    "href": "posts/Standardising Scripts/index.html#config-script-template",
    "title": "More Efficient Working",
    "section": "Config Script Template",
    "text": "Config Script Template\n\nsnippet cctuconfigtemplate\n    ## ─────────────────────────────────────────────────────────────────────────────\n    ##\n    ## Project: `r paste(gsub(\".*STUDY FOLDER/\",\"\",getwd()))`\n    ##\n    ## Purpose of script:\n    ##\n    ## Author: \n    ##\n    ## Date Created: `r paste(format(Sys.time(), \"%d-%m-%Y\"))`\n    ##\n    ## QC'd by:\n    ## QC date:\n    ##\n    ## ─────────────────────────────────────────────────────────────────────────────\n    ##\n    ## Notes:\n    ##   \n    ##\n    ## ─────────────────────────────────────────────────────────────────────────────\n    ##\n    ## \n    ## Preliminary -----------------------------------------------------------------\n    message(\"Preliminary\")\n\n    # Remove objects from workspace\n    rm(list = ls())\n    \n    ## Options ---------------------------------------------------------------------\n    \n    options(verbose = TRUE, stringsAsFactors = FALSE)\n\n    ## Load packages ---------------------------------------------------------------\n    message(\"Load packages\")\n    # List of packages to be used\n    packages &lt;-\n      c(\n            \"magrittr\",\n            \"dplyr\",\n            \"tidyr\",\n            \"ggplot2\",\n            \"dplyr\",\n            \"lubridate\",\n            \"RODBC\",\n            \"data.table\",\n            \"stringr\",\n            \"grid\",\n            \"gridExtra\"\n            )\n\n\n    # Install cctu package (needs devtools)\n    # Install packages which aren't installed in \"packages\"\n    # if (length(packages[!(packages %in% installed.packages()[, \"Package\"])]))\n    #   install.packages(packages[!(packages %in% installed.packages()[, \"Package\"])])\n    # Load packages\n    lapply(packages, library, character.only = TRUE)\n\n    # source functions from sub folder functions\n    file.sources = list.files(\n    c(\"progs/functions\"),\n    pattern = \"\\\\.R$\",\n    full.names = TRUE,\n    ignore.case = T\n    )\n\n    sapply(file.sources,source)\n    # define theme for figures\n    default_theme &lt;- theme_get()\n\n    graphical_theme &lt;- theme_bw() + theme(\n     axis.line.x      = element_line(color = \"black\")\n     axis.line.y      = element_line(color = \"black\"),\n     panel.grid.major = element_blank() ,\n     panel.grid.minor = element_blank(),\n     panel.background = element_blank(),\n     # panel.border = element_blank(),\n     # axis.text = element_text(size = rel(1), angle = 45)\n     axis.title.x     = element_text(margin = margin(t = 10)),\n     legend.key       = element_rect(colour = \"white\", fill = NA),\n     strip.background = element_rect(colour = \"black\")\n    )"
  }
]